<!DOCTYPE html>  
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <title>4-ChallengeInstructions</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style id="mkstylesheet">
body{-webkit-font-smoothing:antialiased;font-family:"Helvetica Neue",Helvetica,Arial,Verdana,sans-serif;margin:30px 0 0;padding:0;background:#fff}#wrapper{padding:20px}li{font-size:110%}li li{font-size:100%}li p{font-size:100%;margin:.5em 0}h1{color:#000}h2{color:#111}h3{color:#111;margin:0}h4{color:#111}h5{color:#111}h6{font-size:1em;line-height:1.5em;margin:1.5em 0}body,p,td,div{color:#111;font-family:"Helvetica Neue",Helvetica,Arial,Verdana,sans-serif;word-wrap:break-word}a{color:#0d6ea1;text-decoration:none;-webkit-transition:color 0.2s ease-in-out;-moz-transition:color 0.2s ease-in-out;-o-transition:color 0.2s ease-in-out;-ms-transition:color 0.2s ease-in-out;transition:color 0.2s ease-in-out}a:hover{color:#3593d9}body{font-size:15px;line-height:21px;margin:0 auto}h1{font-size:37px;line-height:42px;margin-top:42px;margin-bottom:21px}h2{font-size:27px;line-height:42px;margin-top:42px;margin-bottom:21px}h3{font-size:20px;line-height:21px;margin-top:21px;margin-bottom:21px}h4{font-size:20px;line-height:21px;margin-top:21px;margin-bottom:21px}p,ul,ol,pre,table,blockquote{margin-top:21px;margin-bottom:21px}hr{border:1px solid;margin:-1px 0}ul ul,ol ol,ul ol,ol ul{margin-top:0;margin-bottom:0}b,strong,em,small,code{line-height:1}.footnote{color:#0d6ea1;font-size:.8em;vertical-align:super}abbr,acronym{border-bottom:1px dotted #aaa}#wrapper img{max-width:100%;height:auto}dd{font-size:1em;margin-bottom:1em}li>p:first-child{margin:0}ul ul,ul ol{margin-bottom:.4em}caption,col,colgroup,table,tbody,td,tfoot,th,thead,tr{border-spacing:0}table{border:1px solid rgba(0,0,0,0.25);border-collapse:collapse;display:table;empty-cells:hide;margin:-1px 0 1.3125em;padding:0;table-layout:fixed}caption{display:table-caption;font-weight:700}col{display:table-column}colgroup{display:table-column-group}tbody{display:table-row-group}tfoot{display:table-footer-group}thead{display:table-header-group}td,th{display:table-cell}tr{display:table-row}table th,table td{font-size:1.1em;line-height:1.3;padding:.5em 1em 0}table thead{background:rgba(0,0,0,0.15);border:1px solid rgba(0,0,0,0.15);border-bottom:1px solid rgba(0,0,0,0.2)}table tbody{background:rgba(0,0,0,0.05)}table tfoot{background:rgba(0,0,0,0.15);border:1px solid rgba(0,0,0,0.15);border-top:1px solid rgba(0,0,0,0.2)}figure{display:inline-block;overflow:hidden;position:relative;margin:1em 0 2em}figcaption{font-style:italic;text-align:center;background:white;color:#666}.poetry pre{display:block;font-family:Georgia,Garamond,serif !important;font-size:110% !important;font-style:italic;line-height:1.6em;margin-left:1em}.poetry pre code{font-family:Georgia,Garamond,serif !important;word-break:break-all;word-break:break-word;-webkit-hyphens:auto;-moz-hyphens:auto;hyphens:auto;white-space:pre-wrap}blockquote p{font-size:110%;font-style:italic;line-height:1.6em}sup,sub,a.footnote{font-size:1.4ex;height:0;line-height:1;position:relative;vertical-align:super}sub{vertical-align:sub;top:-1px}p,h5{font-size:1.1429em;line-height:1.3125em;margin:1.3125em 0}dt,th{font-weight:700}table tr:nth-child(odd),table th:nth-child(odd),table td:nth-child(odd){background:rgba(255,255,255,0.06)}table tr:nth-child(even),table td:nth-child(even){background:rgba(200,200,200,0.25)}@media print{img,table,figure{page-break-inside:avoid}#wrapper{background:#fff;color:#303030;padding:10px;position:relative;text-indent:0}}@media screen{.inverted{background:#252a2a}.inverted #wrapper{background:#252a2a;color:#eee}.inverted hr{border-color:#333f40 !important}.inverted p,.inverted td,.inverted li,.inverted h1,.inverted h2,.inverted h3,.inverted h4,.inverted h5,.inverted h6,.inverted th,.inverted .math,.inverted caption,.inverted dt,.inverted dd{color:#eee}.inverted pre{background:#ccc}.inverted pre code{color:#111}.inverted table{background:none}.inverted table tr:nth-child(odd),.inverted table td:nth-child(odd){background:none}.inverted a{color:#acd1d5}::selection{background:rgba(157,193,200,0.5)}h1::selection{background-color:rgba(45,156,208,0.3)}h2::selection{background-color:rgba(90,182,224,0.3)}h3::selection,h4::selection,h5::selection,h6::selection,li::selection,ol::selection{background-color:rgba(133,201,232,0.3)}code::selection{background-color:rgba(0,0,0,0.7);color:#eee}code span::selection{background-color:rgba(0,0,0,0.7) !important;color:#eee !important}a::selection{background-color:rgba(255,230,102,0.2)}.inverted a::selection{background-color:rgba(255,230,102,0.6)}td::selection,th::selection,caption::selection{background-color:rgba(180,237,95,0.5)}}

@media print{
#generated-toc-clone,#generated-toc{display:none!important}
}
#generated-toc-clone li.missing,#mkreplaced-toc li.missing{list-style-type:none!important}#generated-toc-clone li, #mkreplaced-toc li{list-style-type:upper-roman}#generated-toc-clone li li, #mkreplaced-toc li li{list-style-type:decimal}#generated-toc-clone li li li,#mkreplaced-toc li li li{list-style-type:decimal-leading-zero}#generated-toc-clone li li li li,#mkreplaced-toc li li li li{list-style-type:lower-greek}#generated-toc-clone li li li li li,#mkreplaced-toc li li li li li{list-style-type:disc}#generated-toc-clone li li li li li li,#mkreplaced-toc li li li li li li{list-style-type:square}
</style>

</head>
<body class="normal">
  <div id="wrapper">
      <h1 id="303:effortlessresponsivenesswithasyncdisplaykitpart4:challengeinstructions">303: Effortless Responsiveness with AsyncDisplayKit, Part 4: Challenge Instructions</h1>

<p>We&#8217;ve actually been using self sizing nodes this whole time. It&#8217;s time to take it to another level.</p>

<p>There are a ton of things that can slow down a collection view, keeping the collection view from reaching 60 frames per second during scroll. Text layout and display is one of them. So one technique to avoid this bottleneck is to hide the text until the user needs it, like we did in the lab. But ideally we could just display the text right under the image, giving the app a more magazine-like feel.</p>

<h2 id="a:selfsizingnodecells">A: Self Sizing Node Cells</h2>

<p>Your challenge, should you choose to accept it, is to rebuild the CardNode from the lab so that the card displays the description text below the image. Each node should be sized precisely to fit its contents (one image and a paragraph of text).</p>

<p>By the time you have finished this challenge you will have mastered the first step towards asynchronous display, the art of node hierarchy construction.</p>

<figure>
<img src="./4-ChallengeImages/Challenge_1.png" alt="" />
</figure>

<p>Go ahead and open <strong>ChallengeViewController.swift</strong>. It&#8217;s the same view controller you just implemented in the lab except it&#8217;s using a different CellNode class. Build and run. Notice how the collection view in the Challenge tab looks exactly the same as the one in the Demo tab. That&#8217;s your starting point. Before looking at the hints below, try to build the new layout and think through what all has to change. :]</p>

<h3 id="hints">Hints</h3>

<ol>
<li>You don&#8217;t need the more button nor the blurred image</li>
<li>Now that the blur node is gone, the description node needs to be added to the card node</li>
<li>Next part is key, <code>calculateSizeThatFits</code> needs to<br/>
 A. Measure the description text node with a constrained <strong>width</strong> that equals the image&#8217;s width minus 40 point padding<br/>
 B. Measure the description text node with a constrained <strong>height</strong> that equals the constrained size passed into the method<br/>
 C. Return a size, specifically a height, that is based on the image and description node measurement<br/>
 D. Return a size, specifically a width, that is baded on the image&#8217;s measured width</li>
<li>The description node needs to have it&#8217;s frame calculated in the FrameSet class</li>
</ol>

<p>If you get this working, congrats â€“ you&#8217;ve earned the master node craftsman title! :]</p>

<h2 id="b:detailview">B: Detail View</h2>

<p>This next challenge involves creating a new view controller and ASDisplayNode subclass from scratch. Each card has additional details that should be presented full screen:</p>

<figure>
<img src="./4-ChallengeImages/Challenge_2.png" alt="" />
</figure>

<p>Think through all the necessary steps that need to occur in order to present a full screen view controller in response to a collection view cell selection. Here are some important tips:</p>

<ul>
<li>The modal transition style should be <code>CrossDissolve</code></li>
<li>Use <code>NSAttributedString.attributedStringForSubtitleText(&quot;&quot;)</code> to create the location attributed string</li>
<li>The Card data model has properties for detail description, location, and year build</li>
</ul>

<p>As in the last challenge, try completing the challenge before looking at the hints below.</p>

<h3 id="hints">Hints</h3>

<ol>
<li><code>ASCollectionViewDelegate</code> is your friend</li>
<li>Try presenting an empty view controller in <code>collectionView(collectionView: ASCollectionView!, didSelectItemAtIndexPath indexPath: NSIndexPath!)</code></li>
<li>The new view controller will want to have the card data model object, so will your node subclass</li>
<li>Go ahead and build the new <code>ASDisplayNode</code> subclass before finishing the view controller</li>
<li>Yup, set the background blur image node&#8217;s content mode to <code>.ScaleAspectFill</code></li>
<li>The blur image node&#8217;s image modification block property needs to be set in order to display a blurred image</li>
<li>Remember the helper computed property <code>blurClosure</code> that returns a closure that should be used to set the image modification block property (this helper computed property can be accessed from the blur node instance itself)</li>
<li>Since this node is full-screen <code>calculateSizeThatFits(constrainedSize: CGSize)</code> should simply return the passed in size, callers should pass in the screen&#8217;s size</li>
<li>Don&#8217;t forget to measure all your subnodes (except for the background blur) in <code>calculateSizeThatFits(constrainedSize: CGSize)</code></li>
<li>Also don&#8217;t forget to calculate frames in <code>layout()</code> (don&#8217;t worry about creating a frameset class for this node)</li>
<li>Eeek, the node has to trigger a view controller dismissal for the close button. Closures are your friend</li>
<li>More specifically, you can have an exit closure property on the node subclass that the view controller can set with the correct dismissal logic</li>
<li>The new view controller sure is different. It probably wants to wait until <code>viewWillLayoutSubviews()</code> before constructing its node</li>
<li>That&#8217;s because the view controller won&#8217;t know its root view&#8217;s frame until <code>viewWillLayoutSubviews()</code> and you&#8217;ll want to pass in the view&#8217;s frame size into <code>measure()</code></li>
<li>Don&#8217;t forget to give the node an exit closure</li>
<li>This is <strong>important</strong>. In the node subclass, make sure to call <code>recursivelyReclaimMemory()</code> before calling the exit closure or else you&#8217;ll hang on to memory you wish you hadn&#8217;t</li>
</ol>

<p>OK. Now you <em>really</em> know what&#8217;s up. You&#8217;ve built a view controller and its root node&#8217;s subclass entirely from scratch! Not so fast&#8230; When tapping on a cell, the background blur appears a second or two after the view controller is presented. Wouldn&#8217;t it be nice to fade in the blur along with all the text (except for the title)?</p>

<h2 id="c:smoothblurappearance">C: Smooth Blur Appearance</h2>

<p>In this challenge you&#8217;ll implement <code>subnodeDisplayDidFinish(subnode: ASDisplayNode!)</code>. This method is useful for performing any steps in response to a subnode finishing drawing. For example, in this challenge the method will be used to nicely fade-in the blur alongside the contents. For the last and final challenge follow these steps:</p>

<ol>
<li>Hide the location, description, and year text nodes when setting them up</li>
<li>Also hide the background blur node during setup</li>
<li>In the detail <code>ASDisplayNode</code> subclass, implement <code>subnodeDisplayDidFinish(subnode: ASDisplayNode!)</code>, don&#8217;t forget to call super!</li>
<li>If the passed in subnode is the background blur, animate in (0.5 secondds) the background along with the text nodes</li>
</ol>

<p>Doesn&#8217;t that feel much nicer! The view controller is presented immediately with the title to let the user know they tapped on the right cell. Then, once the blur operation is complete, the rest of the content shows up. Now that you can layout and display asynchronously, remember that it&#8217;s important to present the user with a super fluid experience especially while display is occurring in the background and the user is in a waiting state.</p>

<p>Congratulations! You&#8217;re now ready to start using AsyncDisplayKit out in the real world. And don&#8217;t forget: friends don&#8217;t let friends display irresponsively.</p>
<!-- ##END MARKED WRAPPER## -->
    </div>
</body>
</html>